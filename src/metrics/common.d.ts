// @generated by protobuf-ts 2.11.0 with parameter output_javascript
// @generated from protobuf file "pbf/metrics/common.proto" (package "metrics", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Action is the request body for any given action.
 *
 *     {
 *         "labels": {
 *             "key": "value"
 *         },
 *         "metric": "teams_bridge_error_total",
 *         "number": 3.141592
 *     }
 *
 *
 * @generated from protobuf message metrics.Action
 */
export interface Action {
  /**
   * labels is the optional set of key-value pairs whitelisted per metric.
   * Providing labels that are not whitelisted causes the entire RPC to be
   * rejected on a request level.
   *
   * @generated from protobuf field: map<string, string> labels = 100
   */
  labels: {
    [key: string]: string;
  };
  /**
   * metric is the required metric name in camel case format. Providing metric
   * names that are not whitelisted causes the entire RPC to be rejected on a
   * request level. Metric names must not be longer than 255 characters.
   *
   * @generated from protobuf field: string metric = 200
   */
  metric: string;
  /**
   * number is the required floating point value that should be applied to the
   * timeseries specified by the labels and metric properties. Negative values
   * may cause the entire RPC to be rejected on a per metric basis.
   *
   * @generated from protobuf field: double number = 300
   */
  number: number;
}
/**
 * @generated from protobuf message metrics.Reason
 */
export interface Reason {
  /**
   * @generated from protobuf field: string info = 100
   */
  info: string;
  /**
   * @generated from protobuf field: string kind = 200
   */
  kind: string;
}
/**
 * Result is the response body for any given action.
 *
 *     {
 *         "reason": {
 *             "desc": "This is why the request was rejected.",
 *             "kind": "someErrorCode"
 *         },
 *         "status": "failure"
 *     }
 *
 *
 * @generated from protobuf message metrics.Result
 */
export interface Result {
  /**
   * reason is the optional feedback that the backend provides in case of
   * action failure.
   *
   * @generated from protobuf field: optional metrics.Reason reason = 100
   */
  reason?: Reason;
  /**
   * status is the final state of the executed action.
   *
   *     success, the given actions were executed successfully
   *
   *     failure, the given actions were rejected for reasons
   *
   *
   * @generated from protobuf field: string status = 200
   */
  status: string;
}
declare class Action$Type extends MessageType<Action> {
  constructor();
  create(value?: PartialMessage<Action>): Action;
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Action,
  ): Action;
  private binaryReadMap100;
  internalBinaryWrite(
    message: Action,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message metrics.Action
 */
export declare const Action: Action$Type;
declare class Reason$Type extends MessageType<Reason> {
  constructor();
  create(value?: PartialMessage<Reason>): Reason;
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Reason,
  ): Reason;
  internalBinaryWrite(
    message: Reason,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message metrics.Reason
 */
export declare const Reason: Reason$Type;
declare class Result$Type extends MessageType<Result> {
  constructor();
  create(value?: PartialMessage<Result>): Result;
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Result,
  ): Result;
  internalBinaryWrite(
    message: Result,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message metrics.Result
 */
export declare const Result: Result$Type;
export {};
